@using MudBlazor
@typeparam TItem

<TableWithToolbar TItem="TItem"
                  Title="@Title"
                  Items="@Items"
                  ShowSearch="@ShowSearch"
                  SearchText="@SearchText"
                  SearchTextChanged="SearchTextChanged"
                  SearchPlaceholder="@SearchPlaceholder"
                  SearchBoxMaxWidth="@SearchBoxMaxWidth"
                  Filter="@Filter"
                  Outlined="@Outlined" Hover="@Hover" Dense="@Dense" Bordered="@Bordered"
                  FixedHeader="@FixedHeader" FixedFooter="@FixedFooter"
                  Elevation="@Elevation" Class="@Class"
                  Height="@Height"
                  Page="@Page" PageChanged="PageChanged"
                  @attributes="AdditionalAttributes">

    <!-- ▼ ツールバー：バッジ＋一括削除、モバイル用「全選択」チェック、外部差し込み -->
    <ToolbarContent Context="tb">
        <!-- モバイル時のみ：検索結果に対する全選択 -->
        <MudHidden Breakpoint="Breakpoint.MdAndUp">
            <div style="width:100%">
                <MudCheckBox T="bool"
                             Value="@_selectAll"
                             ValueChanged="@OnSelectAllChanged"
                             Dense="true"
                             Label="@MobileSelectAllLabel" />
            </div>
        </MudHidden>

        <!-- 外部ツールバー要素（従来API互換）。小画面FullWidthは呼び出し側で ctx.IsMdUp を参照して指定 -->
        @if (ToolbarContent is not null)
        {
            var ctx = new SelectableTableToolbarContext
            {
                SelectedCountInView = SelectedCountInView,
                IsMdUp = tb.IsMdUp,
                SearchText = tb.SearchText,
                GetSelectedIdsInView = () => SelectedIdsInView.ToHashSet(),
                GetSelectedIdsAll = () => new HashSet<Guid>(_selected)
            };

            @* 大画面：横並び / 小画面：縦並び（FullWidthは呼び出し側で FullWidth="@(!ctx.IsMdUp)" 指定） *@
            @if (tb.IsMdUp)
            {
                <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                    @ToolbarContent(ctx)
                </MudStack>
            }
            else
            {
                <MudStack Row="false" Spacing="2" AlignItems="AlignItems.Stretch" Class="w-100">
                    @ToolbarContent(ctx)
                </MudStack>
            }
        }
        <!-- “表示中に含まれる選択数”を表示（小画面は幅100%） -->
        <MudBadge Content="@SelectedCountInView"
                  Max="@(99999)" Color="Color.Error"
                  Style="@(!tb.IsMdUp ? "width:100%" : null)"
                  Overlap="true" Bordered="true">
            <MudButton Variant="Variant.Outlined" Size="@ButtonSize" Color="Color.Error"
                       StartIcon="@Icons.Material.TwoTone.Delete"
                       Disabled="@(SelectedCountInView == 0)"
                       FullWidth="@(!tb.IsMdUp)"
                       OnClick="TriggerBulkDeleteAsync">
                @BulkDeleteLabel
            </MudButton>
        </MudBadge>


    </ToolbarContent>

    <!-- ▼ ヘッダ：左端に選択チェック列 -->
    <HeaderCells>
        <MudTh style="width:48px;text-align:center;">
            @if (IsMdUp)   @* = CurrentBreakpoint >= Breakpoint.Md *@
            {
                <MudCheckBox T="bool"
                             Value="@_selectAll"
                             ValueChanged="@OnSelectAllChanged" />
            }
        </MudTh>
        @HeaderCells
    </HeaderCells>

    <!-- ▼ 行テンプレート：左端に選択チェック列（セルクリックでトグル／チェックは伝播停止） -->
    <RowCells Context="context">
        <MudTd style="width:48px;text-align:center; cursor:pointer;"
               @onclick="@(() => ToggleRow(GetId(context), !IsSelected(GetId(context))))">
            <div @onclick:stopPropagation="true" @onmousedown:stopPropagation="true">
                <MudCheckBox @key="GetId(context)" T="bool"
                             Value="@IsSelected(GetId(context))"
                             ValueChanged="@( (bool v) => ToggleRow(GetId(context), v) )" />
            </div>
        </MudTd>

        @RowCells(context)
    </RowCells>

    <!-- ▼ ページャ／レコード無し表示はそのまま委譲 -->
    <PagerContent>
        @PagerContent
    </PagerContent>

    <NoRecordsContent>
        @NoRecordsContent
    </NoRecordsContent>
</TableWithToolbar>

@code {
    // ---- レスポンシブ（TableWithToolbar 側でも使われますが、こちらも参照します） ----
    [CascadingParameter] public Breakpoint CurrentBreakpoint { get; set; } = Breakpoint.Xl;
    private bool IsMdUp => CurrentBreakpoint >= Breakpoint.Md;

    // ---- 必須 ----
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    [Parameter] public Func<TItem, Guid> IdSelector { get; set; } = default!;

    // ---- スロット（従来API互換） ----
    [Parameter] public RenderFragment? HeaderCells { get; set; }
    [Parameter] public RenderFragment<TItem>? RowCells { get; set; }
    [Parameter] public RenderFragment? PagerContent { get; set; }
    [Parameter] public RenderFragment? NoRecordsContent { get; set; }
    [Parameter] public RenderFragment<SelectableTableToolbarContext>? ToolbarContent { get; set; }

    // ---- 検索 ----
    [Parameter] public bool ShowSearch { get; set; } = true;
    [Parameter] public string SearchText { get; set; } = "";
    [Parameter] public EventCallback<string> SearchTextChanged { get; set; }
    [Parameter] public string SearchPlaceholder { get; set; } = "検索";
    [Parameter] public string SearchBoxMaxWidth { get; set; } = "400px";
    [Parameter] public Func<TItem, string, bool>? Filter { get; set; }

    // ---- 見た目／テーブル設定 ----
    [Parameter] public string? Title { get; set; }         // 追加：任意のタイトル
    [Parameter] public bool Outlined { get; set; } = true;
    [Parameter] public bool Hover { get; set; } = true;
    [Parameter] public bool Dense { get; set; } = true;
    [Parameter] public bool Bordered { get; set; } = true;
    [Parameter] public bool FixedHeader { get; set; } = true;
    [Parameter] public bool FixedFooter { get; set; } = true;
    [Parameter] public int Elevation { get; set; } = AppConstants.DEFAULT_ELEVATION;
    [Parameter] public string? Class { get; set; } = "px-4";
    [Parameter] public string? Height { get; set; } = "500px";
    [Parameter] public Size ButtonSize { get; set; } = AppConstants.SIZE_BUTTON;

    // ---- 選択 ----
    [Parameter] public HashSet<Guid>? SelectedIds { get; set; }
    [Parameter] public EventCallback<HashSet<Guid>> SelectedIdsChanged { get; set; }

    // ---- ページング ----
    [Parameter] public int Page { get; set; }
    [Parameter] public EventCallback<int> PageChanged { get; set; }
    [Parameter] public int RowsPerPage { get; set; } = 10;

    // ---- 一括削除（外へ通知） ----
    [Parameter] public EventCallback<HashSet<Guid>> OnBulkDelete { get; set; }
    [Parameter] public string BulkDeleteLabel { get; set; } = "一括削除";
    [Parameter] public string MobileSelectAllLabel { get; set; } = "全選択（検索結果）";

    // ---- その他委譲 ----
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    // ---- 内部状態 ----
    private HashSet<Guid> _selected = new();
    private bool _selectAll;

    // TableWithToolbar と同じフィルタロジックで“表示中”集合を計算（選択数表示や全選択に使用）
    private IEnumerable<TItem> ItemsView =>
        (Items ?? Enumerable.Empty<TItem>())
        .Where(x => Filter is null || Filter(x, SearchText));

    protected override void OnParametersSet()
    {
        if (SelectedIds is not null)
            _selected = new HashSet<Guid>(SelectedIds); // 参照共有を避ける
        RecalcSelectAll();
    }

    // ---- 選択ロジック ----
    private Guid GetId(TItem item) => IdSelector(item);
    private bool IsSelected(Guid id) => _selected.Contains(id);

    // “表示中に含まれる選択だけ”を数える
    private IEnumerable<Guid> SelectedIdsInView =>
        ItemsView.Select(GetId).Where(id => _selected.Contains(id));
    private int SelectedCountInView => SelectedIdsInView.Count();

    private async Task OnSearchChanged(string value)
    {
        if (SearchText == value) return;
        SearchText = value;
        if (SearchTextChanged.HasDelegate)
            await SearchTextChanged.InvokeAsync(value); // 親へ通知（@bind-SearchText対応）
        RecalcSelectAll(); // 表示集合が変わるため再計算
    }

    private void ToggleRow(Guid id, bool isChecked)
    {
        if (isChecked) _selected.Add(id);
        else _selected.Remove(id);
        RecalcSelectAll();
        _ = NotifySelectionChangedAsync();
    }

    private void OnSelectAllChanged(bool v)
    {
        foreach (var x in ItemsView)
        {
            var id = GetId(x);
            if (v) _selected.Add(id); else _selected.Remove(id);
        }
        RecalcSelectAll();
        _ = NotifySelectionChangedAsync();
    }

    private void RecalcSelectAll()
    {
        var all = ItemsView.Select(GetId).ToList();
        _selectAll = all.Count > 0 && all.All(_selected.Contains);
        StateHasChanged();
    }

    private Task NotifySelectionChangedAsync()
        => SelectedIdsChanged.HasDelegate
            ? SelectedIdsChanged.InvokeAsync(new HashSet<Guid>(_selected))
            : Task.CompletedTask;

    private async Task OnTablePageChanged(int v)
    {
        if (Page != v)
        {
            Page = v;
            RecalcSelectAll();
            if (PageChanged.HasDelegate)
                await PageChanged.InvokeAsync(v);
        }
    }

    // 一括削除：表示中に含まれる選択のみ外へ渡す
    private async Task TriggerBulkDeleteAsync()
    {
        var ids = SelectedIdsInView.ToHashSet();
        if (ids.Count == 0) return;

        if (OnBulkDelete.HasDelegate)
            await OnBulkDelete.InvokeAsync(ids);
    }

    // ★ ツールバー用コンテキスト（従来API互換）
    public class SelectableTableToolbarContext
    {
        public int SelectedCountInView { get; set; }
        public bool IsMdUp { get; set; }
        public string SearchText { get; set; } = "";
        public Func<HashSet<Guid>>? GetSelectedIdsInView { get; set; }
        public Func<HashSet<Guid>>? GetSelectedIdsAll { get; set; }
    }
}
