@inject JsInteropManager Js

@if (Show && !_targetVisible)
{
    <MudPaper class="@($"floating-indicator {CssClass}")"
              Style="@BuildStyle()"
              Elevation="6">
        <MudStack Row Spacing="2" AlignItems="AlignItems.Center">
            @if (!string.IsNullOrWhiteSpace(Icon))
            {
                <MudIcon Icon="@Icon" />
            }
            @if (!string.IsNullOrWhiteSpace(Label))
            {
                <MudText Typo="Typo.subtitle2">@Label</MudText>
            }
            @if (Count is not null)
            {
                <MudChip T="string" Color="Color.Primary" Variant="Variant.Filled" Label="true">
                    @FormatCount(Count!.Value)
                </MudChip>
            }
            <MudSpacer />
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@ActionIcon"
                       Disabled="@Disabled"
                       OnClick="HandleClick">
                @ActionText
            </MudButton>
        </MudStack>
    </MudPaper>
}

@code {
    [Parameter] public bool Show { get; set; } = true;
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public string Icon { get; set; } = Icons.Material.TwoTone.MenuBook;
    [Parameter] public string Label { get; set; } = "";
    [Parameter] public int? Count { get; set; }
    [Parameter] public int CountMax { get; set; } = 99999;
    [Parameter] public string ActionText { get; set; } = "表示";
    [Parameter] public string ActionIcon { get; set; } = Icons.Material.Filled.ArrowDownward;
    [Parameter] public string? TargetElementId { get; set; }   // ← これを監視対象に使う
    [Parameter] public bool Smooth { get; set; } = true;
    [Parameter] public EventCallback OnClick { get; set; }
    [Parameter] public int Right { get; set; } = 20;
    [Parameter] public int Bottom { get; set; } = 20;
    [Parameter] public string CssClass { get; set; } = "";
    [Parameter] public string? Style { get; set; }

    private bool _targetVisible;          // ← 画面内に見えたら true
    private string? _obsId;
    private DotNetObjectReference<object>? _selfRef;

    private string FormatCount(int v) => v > CountMax ? $"{CountMax}+" : v.ToString();

    private async Task HandleClick()
    {
        if (OnClick.HasDelegate) { await OnClick.InvokeAsync(); return; }
        if (!string.IsNullOrWhiteSpace(TargetElementId))
            await Js.ScrollToIdAsync(TargetElementId!, Smooth);
    }

    private string BuildStyle()
        => string.IsNullOrWhiteSpace(Style)
           ? $"position:fixed;right:{Right}px;bottom:{Bottom}px;z-index:{AppZIndex.FloatingUi};padding:8px 12px;border-radius:12px;"
           : Style!;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !string.IsNullOrWhiteSpace(TargetElementId))
        {
            _selfRef = DotNetObjectReference.Create<object>(this);
            _obsId = await Js.ObserveElementVisibilityAsync(TargetElementId!, _selfRef);
        }
    }

    [JSInvokable]
    public void OnTargetVisibilityChanged(bool isVisible)
    {
        _targetVisible = isVisible;
        InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        if (!string.IsNullOrEmpty(_obsId))
            await Js.UnobserveElementVisibilityAsync(_obsId);
        _selfRef?.Dispose();
    }
}

<style>
    .floating-indicator {
        animation: fi-fade-in .18s ease-out;
    }

    @@keyframes fi-fade-in {
        from {
            opacity: 0;
            transform: translateY(6px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
</style>
