@page "/diary/edit/{date:datetime}"
@attribute [Authorize]

@using Blazored.FluentValidation
@using Microsoft.AspNetCore.Components.Forms

@inject EnglishDiaryService DiaryService
@inject IDialogService DialogService
@inject UiOperationRunner UiOperationRunner
@inject ISnackbar Snackbar
@inject NavigationManager Nav
@inject IServiceProvider ServiceProvider
@inject OperationLimitService OpLimit
@inject OperationTypeService OpType
@inject JsInteropManager JS

<PageTitle>英語日記 添削</PageTitle>
<BackLink Href="/diary/calendar" Text="カレンダーに戻る" />

<MudStack Spacing="2">

    <!-- 見出しは JST の「日付のみ」 -->
    <SectionTitle Title="@($"英語日記 添削 ({_jstDateText})")" />

    <!-- 今日の利用状況 -->
    <MudAlert Severity="Severity.Info" Dense="true" Class="w-100">
        @if (_limitPerDay is null)
        {
            <MudText Typo="Typo.body2">添削の利用状況：無制限</MudText>
        }
        else
        {
            <MudText Typo="Typo.body2">
                添削の利用状況（本日）：@(_usedToday ?? 0) / @_limitPerDay 回（残り @_remainingToday.GetValueOrDefault() 回）
            </MudText>
        }
    </MudAlert>

    <!-- バリデーション：EditContext + Blazored.FluentValidation -->
    <!-- 送信ハンドラは使わず、各ボタンから _editCtx.Validate() を呼んで分岐 -->
    <EditForm EditContext="_editCtx">
        <FluentValidationValidator />

        <BaseCard>
            <MudCardContent Class="pb-0">
                <MudTextField T="string"
                              @bind-Value="_model.Title"
                              For="@(() => _model.Title)"
                              Label="タイトル"
                              Variant="Variant.Outlined"
                              Immediate="true" />
            </MudCardContent>

            <MudCardContent>
                <MudTextField T="string"
                              @bind-Value="_model.Content"
                              For="@(() => _model.Content)"
                              Label="日記"
                              Lines="8"
                              Variant="Variant.Outlined"
                              Immediate="true"
                              Placeholder="今日の出来事や感想などを英語で書いてください" />
            </MudCardContent>

            <MudCardContent>
                <MudTextField T="string"
                              @bind-Value="_model.Note"
                              For="@(() => _model.Note)"
                              Label="添削をより正確にするための補足情報"
                              Lines="4"
                              Variant="Variant.Outlined"
                              Immediate="true"
                              Placeholder="背景、意図、ニュアンス、固有名詞 など" />
            </MudCardContent>

            <MudCardContent>
                <MudText Typo="Typo.subtitle2" Class="mb-1">日記タグ</MudText>

                <!-- DropItemSelector 内蔵の「＋新規」: 親で受けてダイアログ起動 -->
                <DiaryTagSelectorContainer @ref="_tagSelector"
                                           @bind-SelectedItems="SelectedTagItems"
                                           OnAddTagRequested="OnAddTagRequested" />
            </MudCardContent>

            <MudCardContent>
                <MudStack Row="true" Spacing="1">
                    <!-- 添削して保存：上限到達時は無効 -->
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               Disabled="@(_limitPerDay.HasValue && _remainingToday.GetValueOrDefault() <= 0)"
                               OnClick="CorrectAndSaveAsync">
                        添削して保存
                    </MudButton>
                    <!-- 保存のみ（添削なし） -->
                    <MudButton Variant="Variant.Outlined"
                               Color="Color.Secondary"
                               OnClick="SaveOnlyAsync">
                        保存（添削なし）
                    </MudButton>
                </MudStack>
            </MudCardContent>
        </BaseCard>

        @if (!string.IsNullOrWhiteSpace(_model.Correction))
        {
            <div id="@_correctAnchorId">
                <BaseCard>
                    <MudCardContent>
                        <MudText Typo="Typo.subtitle1">添削結果</MudText>
                        <MudPaper Class="pa-3 mt-2" Outlined="true">
                            <MudMarkdown Value="@_model.Correction" />
                        </MudPaper>
                    </MudCardContent>
                </BaseCard>
            </div>
        }
    </EditForm>
</MudStack>

@code {
    [Parameter] public DateTime date { get; set; }

    // モデル
    private EnglishDiaryModel _model = new();

    // 見出し（日付のみ）
    private string _jstDateText = string.Empty;

    // EditContext（Blazored.FluentValidation が拾う）
    private EditContext _editCtx = default!;

    // タグセレクタ参照（ダイアログ後の再読込に使う）
    private DiaryTagSelectorContainer? _tagSelector;

    private const string _correctAnchorId = "diary-correct-anchor";
    private bool _pendingScrollToCorrect;

    // タグ選択（DropItemModel）
    private List<DropItemModel> _selectedTagItems = new();
    private List<DropItemModel> SelectedTagItems
    {
        get => _selectedTagItems;
        set
        {
            _selectedTagItems = value ?? new();
            _model.TagIds = _selectedTagItems.Select(x => x.Key1).Distinct().ToList();
        }
    }

    // 利用上限表示（null は無制限）
    private int? _limitPerDay;
    private int? _remainingToday;
    private int? _usedToday;

    protected override async Task OnInitializedAsync()
    {
        // 先に空の EditContext を用意
        _editCtx = new EditContext(_model);

        // 対象日データ取得 or 新規
        var target = DateOnly.FromDateTime(date);
        var loaded = await UiOperationRunner.ReadAsync(() => DiaryService.GetByDateAsync(target));
        _model = loaded ?? new EnglishDiaryModel
        {
            Id = Guid.NewGuid(),
            Title = string.Empty,
            Content = string.Empty,
            Note = string.Empty,
            CreatedAt = loaded is null ? ToUtcAtTokyoMidnight(target) : _model.CreatedAt,
            UpdatedAt = DateTime.UtcNow
        };

        // 見出しは JST の「yyyy-MM-dd」
        _jstDateText = ToTokyoDateOnlyText(_model.CreatedAt);

        // EditContext を“確定モデル”で再構築
        _editCtx = new EditContext(_model);

        // TagIds → セレクタへ反映
        _selectedTagItems = (_model.TagIds ?? new())
            .Select(id => new DropItemModel { Key1 = id, DropTarget = DropItemType.Target })
            .ToList();

        await LoadUsageAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_pendingScrollToCorrect)
        {
            _pendingScrollToCorrect = false;
            await JS.ScrollToIdAsync(_correctAnchorId, smooth: true);
        }
    }

    private async Task LoadUsageAsync()
    {
        var types = await UiOperationRunner.ReadAsync(() => OpType.GetListAsync());
        var diaryOp = types?.FirstOrDefault(x =>
            string.Equals(x.Code, OperationTypeCode.DiaryCorrection.ToString(), StringComparison.OrdinalIgnoreCase));

        _limitPerDay = (diaryOp?.Limit > 0) ? diaryOp.Limit : (int?)null;

        var chk = await UiOperationRunner.ReadAsync(() => OpLimit.CheckAsync(OperationTypeCode.DiaryCorrection, units: 0));
        _remainingToday = chk?.RemainingToday;

        _usedToday = (_limitPerDay is not null && _remainingToday is not null)
            ? Math.Max(0, _limitPerDay.Value - _remainingToday.Value)
            : null;
    }

    // ===== ボタンハンドラ =====

    private async Task SaveOnlyAsync()
    {
        if (!_editCtx.Validate())
        {
            OnInvalidSubmit(_editCtx);
            return;
        }

        var ok = await DialogService.ShowConfirmAsync(
            DialogConfirmType.InfoConfirm,
            "添削なしで日記を保存します。よろしいですか"
        );
        if (!ok) return;

        var res = await UiOperationRunner.WriteAsync(
            () => DiaryService.UpsertAsync(_model),
            message: "保存しています…"
        );
        if (!res.IsSuccess) return;

        if (res.Data is not null)
        {
            _model = res.Data;
            _jstDateText = ToTokyoDateOnlyText(_model.CreatedAt);
            _editCtx = new EditContext(_model);
            StateHasChanged();
        }

        // 保存だけなので利用回数は変化しないが、別画面で更新された場合に備えて再読込
        await LoadUsageAsync();

    }

    private async Task CorrectAndSaveAsync()
    {
        if (!_editCtx.Validate())
        {
            OnInvalidSubmit(_editCtx);
            return;
        }

        var ok = await DialogService.ShowConfirmAsync(
            DialogConfirmType.InfoConfirm,
            "添削と同時に作成した日記が登録されます。よろしいですか"
        );
        if (!ok) return;

        var op = await UiOperationRunner.WriteAsync(
            () => DiaryService.CorrectAndUpsertAsync(_model),
            message: "添削しています…"
        );
        if (!op.IsSuccess) return;

        if (op.Data is not null)
        {
            _model = op.Data;
            _jstDateText = ToTokyoDateOnlyText(_model.CreatedAt);
            _editCtx = new EditContext(_model);
            _pendingScrollToCorrect = true; // 添削結果へスクロール
            StateHasChanged();
        }

        await LoadUsageAsync();
    }

    private void OnInvalidSubmit(EditContext editContext)
    {
        editContext.PublishPageLevelErrors(ServiceProvider);
        Snackbar.Add("入力内容を確認してください。", MudBlazor.Severity.Warning);
    }

    // ----- TagSelector からの「＋新規」イベント（ダイアログ利用） -----
    private async Task OnAddTagRequested()
    {
        var dlg = await DialogService.ShowWithAsync<DiaryTagFormDialogHost, Guid?>(
            title: "日記タグ登録",
            paramSelector: x => x.GenreId,
            value: null,
            options: DialogServiceExtensions.OptionsMd()
        );

        var result = await dlg.Result;
        if (!(result?.Canceled ?? true))
        {
            await _tagSelector!.ReloadAsync(keepSelection: SelectedTagItems);
        }
    }

    // ----- ヘルパ -----
    private static DateTime ToUtcAtTokyoMidnight(DateOnly localDateJst)
    {
        var tz = GetTokyoTz();
        var localUnspec = new DateTime(localDateJst.Year, localDateJst.Month, localDateJst.Day, 0, 0, 0, DateTimeKind.Unspecified);
        return TimeZoneInfo.ConvertTimeToUtc(localUnspec, tz);
    }

    private static string ToTokyoDateOnlyText(DateTime utc)
    {
        var tz = GetTokyoTz();
        var local = TimeZoneInfo.ConvertTimeFromUtc(utc, tz);
        return DateOnly.FromDateTime(local).ToString("yyyy-MM-dd");
    }

    private static TimeZoneInfo GetTokyoTz()
    {
        try { return TimeZoneInfo.FindSystemTimeZoneById("Tokyo Standard Time"); }
        catch { return TimeZoneInfo.FindSystemTimeZoneById("Asia/Tokyo"); }
    }
}
