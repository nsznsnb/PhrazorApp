@page "/phrases/writing"
@page "/tests/writing"
@attribute [Authorize]

@using System.Text
@using System.Text.RegularExpressions
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using Microsoft.AspNetCore.Components.Web
@using PhrazorApp.Models.Dtos

@inject JsInteropManager JS
@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ProtectedSessionStorage PSS   // PSSのみで復元・保存

<PageTitle>英作文テスト</PageTitle>

<MudStack Spacing="2">
    <SectionTitle Title="英作文テスト" />

    <!-- アクション -->
    <ActionCard>
        <MudText Typo="Typo.subtitle2">
            @(_count == 0 ? "（データなし）" : $"{_index + 1} / {_count}")
        </MudText>

        <MudSwitch T="bool"
                   @bind-Value="_showCorrectBeforeNext"
                   Color="Color.Primary"
                   Class="ml-2"
                   Label="次に進む前に正答を表示" />

        <MudSpacer />

        <MudButton Variant="Variant.Outlined" Color="Color.Secondary"
                   StartIcon="@Icons.Material.TwoTone.Lightbulb"
                   Disabled="@(!_canHint)" OnClick="GiveHint"
                   accesskey="h">
            ヒント <span class="kbd ml-1">Alt + h</span>
        </MudButton>

        <MudButton Variant="Variant.Outlined" Color="Color.Info"
                   StartIcon="@Icons.Material.TwoTone.Visibility"
                   OnClick="@(() => _peek = !_peek)"
                   accesskey="i">
            チラ見 <span class="kbd ml-1">Alt + i</span>
        </MudButton>

        <MudButton Variant="Variant.Outlined" Color="Color.Error"
                   StartIcon="@Icons.Material.TwoTone.StopCircle"
                   OnClick="CancelAsync"
                   accesskey="x">
            テスト中止 <span class="kbd ml-1">Alt + x</span>
        </MudButton>
    </ActionCard>

    <BaseCard>
        <MudStack Spacing="3" AlignItems="AlignItems.Center" Class="py-4">

            <!-- 進捗 -->
            <MudGrid Justify="Justify.Center">
                <MudItem Xs="12" Sm="10" Md="8" LG="7" XL="6">
                    <MudProgressLinear Value="@ProgressPercent" Rounded="true" />
                </MudItem>
            </MudGrid>

            <!-- 出題 -->
            <MudGrid Justify="Justify.Center" Class="mb-1">
                <MudItem Xs="12" Sm="10" Md="8" Lg="7" Xl="6">
                    <MudCard Elevation="10" Class="p-6 qcard">
                        <MudStack Spacing="1" Class="q-stack">
                            <MudText Typo="Typo.subtitle2" Align="Align.Left">No. @_indexPlus1</MudText>
                            <div class="q-body">
                                <MudText Typo="Typo.h6" Align="Align.Center">@_current.Back</MudText>
                            </div>
                        </MudStack>
                    </MudCard>
                </MudItem>
            </MudGrid>

            <!-- 回答 -->
            <MudGrid Justify="Justify.Center">
                <MudItem Xs="12" Sm="10" Md="8" LG="7" XL="6">
                    <EditForm Model="_form" OnSubmit="SubmitAsync">
                        <MudStack @key="_index" Spacing="1" AlignItems="AlignItems.Stretch">

                            <MudTextField T="string"
                                          @bind-Value="Answer"
                                          Variant="Variant.Text"
                                          Lines="2" MaxLines="12"
                                          FullWidth="true"
                                          AutoFocus="true"
                                          Adornment="Adornment.Start"
                                          AdornmentIcon="@Icons.Material.TwoTone.EditNote"
                                          Immediate="true"
                                          Class="mono-input multi tf-answer"
                                          OnKeyDown="HandleAnswerKeyDown" />

                            <MudTextField T="string"
                                          Value="@_assistText"
                                          ReadOnly="true"
                                          Variant="Variant.Text"
                                          Lines="2" MaxLines="12"
                                          FullWidth="true"
                                          Adornment="Adornment.Start"
                                          AdornmentIcon="@Icons.Material.TwoTone.EditNote"
                                          Class="mono-input multi assist-input" />

                            <MudStack Row="true" Wrap="Wrap.Wrap" Spacing="1"
                                      AlignItems="AlignItems.Center" Justify="Justify.Center"
                                      Class="mt-2">

                                <MudButton ButtonType="ButtonType.Submit"
                                           Variant="Variant.Filled" Color="Color.Primary"
                                           StartIcon="@Icons.Material.TwoTone.CheckCircle"
                                           accesskey="s">
                                    解答 <span class="kbd ml-1">Enter</span>
                                </MudButton>

                                <MudButton Variant="Variant.Outlined" Color="Color.Warning"
                                           StartIcon="@Icons.Material.TwoTone.SkipNext"
                                           OnClick="SkipAsWrongAsync"
                                           accesskey="n">
                                    次へ（×扱い） <span class="kbd ml-1">Alt + n</span>
                                </MudButton>

                                <MudButton Variant="Variant.Outlined" Color="Color.Default"
                                           StartIcon="@Icons.Material.TwoTone.RestartAlt"
                                           OnClick="ClearInput"
                                           accesskey="c">
                                    クリア <span class="kbd ml-1">Alt + c</span>
                                </MudButton>

                                <MudChip T="string" Color="Color.Default" Variant="Variant.Outlined">
                                    残り試行 @_attemptsLeft / 5
                                </MudChip>
                                <MudChip T="string" Color="Color.Success" Variant="Variant.Outlined">
                                    正解 @_correctCount
                                </MudChip>
                                <MudChip T="string" Color="Color.Error" Variant="Variant.Outlined">
                                    不正解 @_wrongCount
                                </MudChip>
                            </MudStack>
                        </MudStack>
                    </EditForm>

                    @if (_peek)
                    {
                        <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true" Elevation="0" Class="mt-2">
                            解答（チラ見）：@_current.Front
                        </MudAlert>
                    }
                </MudItem>
            </MudGrid>
        </MudStack>
    </BaseCard>
</MudStack>

<style>
    :root {
        --mono-font-stack: ui-monospace,"Cascadia Mono",Consolas,"SFMono-Regular","Source Code Pro","Noto Sans Mono","Liberation Mono",monospace;
        --mono-size: 1rem;
        --mono-line: 1.5rem;
        --qcard-h: 180px;
    }

    .qcard {
        height: var(--qcard-h);
    }

    .q-stack {
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    .q-body {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow-y: auto;
        text-align: center;
        overflow-wrap: anywhere;
        word-break: normal;
    }

    .mono-input .mud-input-slot textarea {
        font-family: var(--mono-font-stack) !important;
        font-size: var(--mono-size) !important;
        line-height: var(--mono-line) !important;
        letter-spacing: 0 !important;
        white-space: pre-wrap;
        overflow: hidden;
        resize: none;
    }

    .assist-input .mud-input-slot textarea {
        color: rgba(0,0,0,.54);
        caret-color: transparent;
    }

    .assist-input .mud-input-adornment-start {
        visibility: hidden;
    }

    .kbd {
        display: inline-block;
        padding: 0 .35rem;
        border: 1px solid rgba(0,0,0,.18);
        background: rgba(0,0,0,.06);
        border-radius: .25rem;
        font-family: var(--mono-font-stack);
        font-size: .75rem;
        line-height: 1.25rem;
        vertical-align: baseline;
    }

    .ml-1 {
        margin-left: .35rem;
    }
</style>

@code {
    [Parameter, SupplyParameterFromQuery] public string? Return { get; set; }

    private bool _showCorrectBeforeNext;

    // ---- データ（PSSのDTOをそのまま使う） ----
    private List<ReviewCardDto> _items = new();
    private int _index;
    private int _count;
    private int _indexPlus1 => _index + 1;
    private ReviewCardDto _current = new() { PhraseId = Guid.Empty, Front = "", Back = "" };

    // ---- 集計（PSSへ保存するDTO） ----
    private readonly List<TestResultRowDto> _rows = new();
    private int _attemptsLeft = 5;
    private int _answeredCount;
    private int _correctCount;
    private int _wrongCount;
    private double ProgressPercent => _count == 0 ? 0 : (_answeredCount * 100.0 / _count);

    // 入力モデル
    private sealed class AnswerForm { public string Answer { get; set; } = string.Empty; }
    private AnswerForm _form = new();
    private string Answer { get => _form.Answer; set { _form.Answer = value ?? string.Empty; RebuildAssist(); } }

    // 単語ヒント
    private static readonly Regex WordRegex = new(@"[A-Za-z0-9'’]+", RegexOptions.Compiled);
    private List<(int start, int length)> _wordSpans = new();
    private HashSet<int> _revealedWords = new();
    private bool _canHint => _wordSpans.Count > _revealedWords.Count;

    // 補助文字列
    private string _assistText = string.Empty;

    private bool _peek;
    private bool _submitting;

    protected override async Task OnInitializedAsync()
    {
        // PSS（共通DTO）から復元
        var ok = await TryRestoreFromSessionAsync();
        if (!ok)
        {
            Snackbar.Add("テスト対象が設定されていません。復習または候補一覧から選択してください。", Severity.Warning);
            Navigation.NavigateTo("/phrases");
            return;
        }

        // テストは常に先頭から開始（レビュー位置の Index は無視）
        _index = 0;
        LoadCurrent();
    }

    private async Task<bool> TryRestoreFromSessionAsync()
    {
        try
        {
            var got = await PSS.GetAsync<ReviewState>(ReviewStorage.ReviewStateV1);
            var s = got.Success ? got.Value : null;
            if (s is null || s.Items.Count == 0) return false;

            _items = s.Items.ToList();
            _count = _items.Count;
            return _count > 0;
        }
        catch { return false; }
    }

    private void LoadCurrent()
    {
        _current = _items[_index];
        _form.Answer = string.Empty;
        _attemptsLeft = 5;
        _revealedWords.Clear();
        _peek = false;

        _wordSpans = new();
        foreach (Match m in WordRegex.Matches(_current.Front))
            _wordSpans.Add((m.Index, m.Length));

        RebuildAssist();
    }

    // —— ヒント・補助の構築 ——
    private List<int> UnsolvedWordIndices()
    {
        var t = _current.Front ?? string.Empty;
        var u = _form.Answer ?? string.Empty;

        bool CharOk(int i)
        {
            if (i >= u.Length) return false;
            var a = NormalizeAsciiPunct(t[i]);
            var b = NormalizeAsciiPunct(u[i]);
            return char.ToLowerInvariant(a) == char.ToLowerInvariant(b);
        }

        var list = new List<int>();
        for (int wi = 0; wi < _wordSpans.Count; wi++)
        {
            if (_revealedWords.Contains(wi)) continue;
            var (s, len) = _wordSpans[wi];
            bool fullyCorrect = true;
            for (int j = 0; j < len; j++)
                if (!CharOk(s + j)) { fullyCorrect = false; break; }
            if (!fullyCorrect) list.Add(wi);
        }
        return list;
    }

    private void GiveHint()
    {
        var candidates = UnsolvedWordIndices();
        if (candidates.Count == 0) return;

        var rnd = new Random();
        var pick = candidates[rnd.Next(candidates.Count)];
        _revealedWords.Add(pick);
        RebuildAssist();
    }

    private void RebuildAssist()
    {
        var t = _current.Front ?? string.Empty;
        var u = _form.Answer ?? string.Empty;

        var sb = new StringBuilder(t.Length);
        for (int i = 0; i < t.Length; i++)
        {
            var expected = NormalizeAsciiPunct(t[i]);
            if (IsWordChar(expected))
            {
                bool hinted = IsInRevealedWord(i);
                bool typedOk = i < u.Length &&
                               char.ToLowerInvariant(NormalizeAsciiPunct(u[i])) ==
                               char.ToLowerInvariant(expected);

                sb.Append((hinted || typedOk) ? expected : '·');
            }
            else
            {
                sb.Append(expected);
            }
        }
        _assistText = sb.ToString();
        StateHasChanged();
    }

    private bool IsInRevealedWord(int charIndex)
    {
        for (int wi = 0; wi < _wordSpans.Count; wi++)
        {
            var (s, len) = _wordSpans[wi];
            if (charIndex >= s && charIndex < s + len)
                return _revealedWords.Contains(wi);
        }
        return false;
    }

    private static bool IsWordChar(char ch)
        => char.IsLetterOrDigit(ch) || ch == '\'' || ch == '’';

    private static char NormalizeAsciiPunct(char ch) => ch switch
    {
        '’' or '‘' => '\'',
        '“' or '”' => '"',
        '–' or '—' => '-',
        _ => ch
    };

    // —— キーボード操作 ——
    private async Task HandleAnswerKeyDown(KeyboardEventArgs e)
    {
        if (e.AltKey)
        {
            switch (e.Key)
            {
                case "h" or "H": if (_canHint) GiveHint(); return;
                case "i" or "I": _peek = !_peek; StateHasChanged(); return;
                case "c" or "C": ClearInput(); return;
                case "x" or "X": await CancelAsync(); return;
                case "n" or "N": await SkipAsWrongAsync(); return;
                case "s" or "S": await SubmitAsync(); return;
            }
        }

        if (!e.AltKey && !e.CtrlKey && !e.ShiftKey &&
            (e.Key == "Enter" || e.Key == "NumpadEnter"))
        {
            await SubmitAsync();
        }
    }

    private async Task SubmitAsync()
    {
        if (_submitting) return;
        _submitting = true;
        try
        {
            var input = _form.Answer;
            if (string.IsNullOrWhiteSpace(input))
            {
                Snackbar.Add("英作文を入力してください。", Severity.Warning);
                return;
            }

            var user = NormalizeForJudge(input);
            var expected = NormalizeForJudge(_current.Front);

            if (user == expected)
            {
                _correctCount++;
                _answeredCount++;
                _rows.Add(new TestResultRowDto { Front = _current.Front, Back = _current.Back, Correct = true });
                Snackbar.Add("正解です！", Severity.Success);

                if (_showCorrectBeforeNext)
                    await ShowCorrectDialogAsync("正解を確認して次へ進みます。");

                await NextAsync();
            }
            else
            {
                _attemptsLeft--;
                if (_attemptsLeft > 0)
                {
                    Snackbar.Add($"不正解です。もう一度試してください（残り {_attemptsLeft} 回）", Severity.Error);
                }
                else
                {
                    await ProceedWrongAsync();
                }
            }
        }
        finally
        {
            _submitting = false;
        }
    }

    private async Task SkipAsWrongAsync() => await ProceedWrongAsync();

    private async Task ProceedWrongAsync()
    {
        _wrongCount++;
        _answeredCount++;
        _rows.Add(new TestResultRowDto { Front = _current.Front, Back = _current.Back, Correct = false });

        if (_showCorrectBeforeNext)
            await ShowCorrectDialogAsync("不正解として記録しました。正答を確認して次へ進みます。");

        await NextAsync();
    }

    private void ClearInput()
    {
        _form.Answer = string.Empty;
        RebuildAssist();
    }

    private static string NormalizeForJudge(string s)
    {
        var only = new string(s.Where(ch => char.IsLetterOrDigit(ch) || char.IsWhiteSpace(ch)).ToArray());
        var collapsed = Regex.Replace(only, "\\s+", " ").Trim();
        return collapsed.ToLowerInvariant();
    }

    private async Task NextAsync()
    {
        if (_answeredCount >= _count)
        {
            // 結果を PSS へ保存 → 結果ページで確実に復元可能
            var result = new TestResultState
            {
                Rows = _rows.ToList(),
                SavedAtUtc = DateTime.UtcNow
            };
            await PSS.SetAsync(ReviewStorage.ReviewResultV1, result);

            // （任意）出題状態は残しておく。結果ページ側で再テスト時に上書きされる
            Navigation.NavigateTo("/tests/result");
            return;
        }

        _index = Math.Min(_index + 1, _count - 1);
        LoadCurrent();
        await Task.CompletedTask;
    }

    private async Task CancelAsync()
    {
        var ok = await DialogService.ShowConfirmAsync(DialogConfirmType.DangerConfirm, "テストを中止しますか？", "テスト中止確認", "中止");
        if (!ok) return;

        if (!string.IsNullOrEmpty(Return))
        {
            Navigation.NavigateTo(Return);
            return;
        }
        try { await JS.HistoryBackAsync(); }
        catch { Navigation.NavigateTo("/phrases"); }
    }

    private async Task ShowCorrectDialogAsync(string? note = null)
    {
        var html =
            "<div style='white-space:pre-wrap;font-weight:600'>" +
            System.Net.WebUtility.HtmlEncode(_current.Front) +
            "</div>" +
            (string.IsNullOrWhiteSpace(_current.Back)
                ? ""
                : "<div style='white-space:pre-wrap;color:rgba(0,0,0,.6);margin-top:.5rem'>" +
                  System.Net.WebUtility.HtmlEncode(_current.Back) + "</div>") +
            (string.IsNullOrWhiteSpace(note) ? "" : $"<p style='margin-top:12px;color:rgba(0,0,0,.6)'>{System.Net.WebUtility.HtmlEncode(note)}</p>");

        await DialogService.ShowMessageBox("正答", (MarkupString)html, yesText: "次へ");
    }
}
