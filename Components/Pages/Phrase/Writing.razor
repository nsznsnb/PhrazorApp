@page "/phrases/writing"
@attribute [Authorize]

@using System.Text
@using System.Text.RegularExpressions
@using PhrazorApp.Components.State

@inject NavigationManager Navigation
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ReviewSession ReviewSession

<MudStack Spacing="2">
    <SectionTitle Title="英作文テスト" />

    <!-- 上部アクション -->
    <ActionCard>
        <MudText Typo="Typo.subtitle2">
            @(_count == 0 ? "（データなし）" : $"{_index + 1} / {_count}")
        </MudText>

        <MudSpacer />

        <MudButton Variant="Variant.Outlined" Color="Color.Secondary"
                   StartIcon="@Icons.Material.TwoTone.Lightbulb"
                   Disabled="@(!_canHint)" OnClick="GiveHint">
            ヒント
        </MudButton>

        <MudButton Variant="Variant.Outlined" Color="Color.Info"
                   StartIcon="@Icons.Material.TwoTone.Visibility"
                   OnClick="@(() => _peek = !_peek)">
            チラ見
        </MudButton>

        <MudButton Variant="Variant.Outlined" Color="Color.Error"
                   StartIcon="@Icons.Material.TwoTone.StopCircle"
                   OnClick="CancelAsync">
            キャンセル
        </MudButton>
    </ActionCard>

    <BaseCard>
        <MudStack Spacing="3" AlignItems="AlignItems.Center" Class="py-4">

            <!-- 進捗 -->
            <MudProgressLinear Value="@ProgressPercent" Rounded="true" />

            <!-- 出題（日本語：Back） -->
            <MudCard Elevation="10" Class="p-6 text-center">
                <MudText Typo="Typo.h6">@_current.Back</MudText>
            </MudCard>

            <!-- 回答フォーム -->
            <EditForm Model="_form" OnValidSubmit="SubmitAsync">
                <MudStack Spacing="2" AlignItems="AlignItems.Stretch">

                    <!-- 上：入力可（アイコン=EditNote / 同じフォント） -->
                    <MudTextField T="string"
                                  @bind-Value="_form.Answer"
                                  Variant="Variant.Text"
                                  FullWidth="true"
                                  Adornment="Adornment.Start"
                                  AdornmentIcon="@Icons.Material.TwoTone.EditNote"
                                  Immediate="true"
                                  InputStyle="@ProportionalInputStyle" />

                    <!-- 下：ガイド（Mudの入力レイアウトを流用し、同じアイコン＆同じフォントで揃える） -->
                    <MudPaper Class="mud-input mud-input-root answer-guide" Elevation="0">
                        <div class="mud-input-adornment mud-input-adornment-start">
                            <MudIcon Icon="@Icons.Material.TwoTone.EditNote" Size="Size.Medium" />
                        </div>
                        <div class="mud-input-slot" style="@ProportionalInputStyle">@GuideHtml</div>
                    </MudPaper>

                    <!-- ボタンと集計 -->
                    <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center" Justify="Justify.FlexStart">
                        <MudButton ButtonType="ButtonType.Submit"
                                   Variant="Variant.Filled" Color="Color.Primary"
                                   StartIcon="@Icons.Material.TwoTone.CheckCircle">
                            解答
                        </MudButton>

                        <MudButton Variant="Variant.Outlined" Color="Color.Default"
                                   StartIcon="@Icons.Material.TwoTone.RestartAlt"
                                   OnClick="ClearInput">
                            クリア
                        </MudButton>

                        <MudChip T="string" Color="Color.Default" Variant="Variant.Outlined">
                            残り試行 @_attemptsLeft / 5
                        </MudChip>
                        <MudChip T="string" Color="Color.Success" Variant="Variant.Outlined">
                            正解 @_correctCount
                        </MudChip>
                        <MudChip T="string" Color="Color.Error" Variant="Variant.Outlined">
                            不正解 @_wrongCount
                        </MudChip>
                    </MudStack>
                </MudStack>
            </EditForm>

            @if (_peek)
            {
                <MudAlert Severity="Severity.Info" Variant="Variant.Outlined" Dense="true" Elevation="0">
                    解答（チラ見）：@_current.Front
                </MudAlert>
            }
        </MudStack>
    </BaseCard>
</MudStack>
<style>
    /* Writing.razor.css など */
    .answer-guide {
        color: var(--mud-palette-text-secondary, rgba(0,0,0,.6));
    }

        /* 下線だけ見せる“ゴースト文字” */
        .answer-guide .ghost {
            color: transparent; /* 文字は透明 */
            border-bottom: 1px solid black; /* 下線色 = 親の color */
        }

        /* （任意）ヒントで公開した文字を少し強調したい場合 */
        .answer-guide .reveal {
            font-weight: 600;
        }
</style>
@code {
    // 入力欄とガイド欄で共通のタイポ（BIZ UDPGothic）
    private const string ProportionalInputStyle =
        "font-family:'BIZ UDPGothic',system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial,'Noto Sans JP',sans-serif;" +
        "font-weight:400;font-size:1rem;line-height:1.5rem;";
    // データ
    private List<ReviewSession.Card> _items = new();
    private int _index;
    private int _count;
    private ReviewSession.Card _current;

    // フォーム
    private AnswerForm _form = new();
    private sealed class AnswerForm { public string Answer { get; set; } = string.Empty; }

    // ヒント管理
    private HashSet<int> _revealed = new(); // Front の公開済みインデックス
    private bool _peek;

    // 試行回数（各問題）
    private int _attemptsLeft = 5;

    // 集計
    private int _answeredCount;
    private int _correctCount;
    private int _wrongCount;

    private bool _canHint => RemainingLetterIndices().Count > 0;
    private double ProgressPercent => _count == 0 ? 0 : (_answeredCount * 100.0 / _count);

    // ガイドHTML（現行フォントの幅に一致する“下線のみ”を描画）
    private MarkupString GuideHtml => BuildGuideHtml(_current.Front, _revealed);

    protected override void OnInitialized()
    {
        _items = new List<ReviewSession.Card>(ReviewSession.Items);
        _count = _items.Count;

        if (_count == 0)
        {
            Snackbar.Add("テスト対象が設定されていません。フレーズ一覧から選択して開始してください。", Severity.Warning);
            Navigation.NavigateTo("/phrases");
            return;
        }

        _index = 0;
        LoadCurrent();
    }

    private void LoadCurrent()
    {
        _current = _items[_index];
        _form.Answer = string.Empty;
        _attemptsLeft = 5;
        _revealed.Clear();
        _peek = false;
        StateHasChanged();
    }

    // 英数字のインデックスのみ対象
    private static List<int> LetterIndices(string s)
        => s.Select((ch, i) => (ch, i))
            .Where(t => char.IsLetterOrDigit(t.ch))
            .Select(t => t.i).ToList();

    private List<int> RemainingLetterIndices()
    {
        var all = LetterIndices(_current.Front);
        all.RemoveAll(i => _revealed.Contains(i));
        return all;
    }

    // “ゴースト文字の下線”をHTML化：英数字→下線のみ、公開済みは実文字を表示。記号と空白はそのまま表示。
    private static MarkupString BuildGuideHtml(string text, HashSet<int> reveals)
    {
        var sb = new StringBuilder(text.Length * 16);
        for (int i = 0; i < text.Length; i++)
        {
            var ch = text[i];
            if (char.IsLetterOrDigit(ch))
            {
                if (reveals.Contains(i))
                {
                    // ヒントで公開済み：実文字を表示
                    sb.Append("<span class=\"reveal\">")
                      .Append(System.Net.WebUtility.HtmlEncode(ch.ToString()))
                      .Append("</span>");
                }
                else
                {
                    // ゴースト：文字は透明、ボーダーで下線だけ見せる
                    sb.Append("<span class=\"ghost\">")
                      .Append(System.Net.WebUtility.HtmlEncode(ch.ToString()))
                      .Append("</span>");
                }
            }
            else if (ch == ' ')
            {
                sb.Append("&nbsp;"); // 空白はそのまま空間を確保
            }
            else
            {
                // 記号は先に見せる
                sb.Append(System.Net.WebUtility.HtmlEncode(ch.ToString()));
            }
        }
        return new MarkupString(sb.ToString());
    }

    private void GiveHint()
    {
        var remain = RemainingLetterIndices();
        if (remain.Count == 0) return;

        int revealCount = Math.Clamp(remain.Count / 5, 1, 5); // 残りの約20%を目安
        var rnd = new Random();
        for (int n = 0; n < revealCount && remain.Count > 0; n++)
        {
            var pick = remain[rnd.Next(remain.Count)];
            _revealed.Add(pick);
            remain.Remove(pick);
        }

        Snackbar.Add("ヒントを表示しました。", Severity.Info);
    }

    private async Task SubmitAsync()
    {
        var input = _form.Answer;
        if (string.IsNullOrWhiteSpace(input))
        {
            Snackbar.Add("英作文を入力してください。", Severity.Warning);
            return;
        }

        var user = Normalize(input);
        var expected = Normalize(_current.Front);

        if (user == expected)
        {
            _correctCount++;
            _answeredCount++;
            Snackbar.Add("正解です！", Severity.Success);
            await NextAsync();
        }
        else
        {
            _attemptsLeft--;
            if (_attemptsLeft > 0)
            {
                Snackbar.Add($"不正解です。もう一度試してください（残り {_attemptsLeft} 回）", Severity.Error);
            }
            else
            {
                _wrongCount++;
                _answeredCount++;
                Snackbar.Add("不正解。次の問題に進みます。", Severity.Error);
                await NextAsync();
            }
        }
    }

    private void ClearInput() => _form.Answer = string.Empty;

    // 正規化：記号無視・空白圧縮・大小無視
    private static string Normalize(string s)
    {
        var onlyLettersSpaces = new string(s.Where(ch => char.IsLetterOrDigit(ch) || char.IsWhiteSpace(ch)).ToArray());
        var collapsed = Regex.Replace(onlyLettersSpaces, "\\s+", " ").Trim();
        return collapsed.ToLowerInvariant();
    }

    private async Task NextAsync()
    {
        if (_answeredCount >= _count)
        {
            Navigation.NavigateTo($"/phrases/writing/result?total={_count}&correct={_correctCount}&wrong={_wrongCount}");
            return;
        }

        _index = Math.Min(_index + 1, _count - 1);
        LoadCurrent();
        await Task.CompletedTask;
    }

    private async Task CancelAsync()
    {
        var ok = await DialogService.ShowConfirmAsync(DialogConfirmType.DeleteConfirm, "テストを中止して一覧に戻りますか？");
        if (ok) Navigation.NavigateTo("/phrases");
    }
}
