@page "/phrases/review"
@page "/tests/review"

@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using PhrazorApp.Models.Dtos
@attribute [Authorize]

@inject JsInteropManager JS
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject ProtectedSessionStorage PSS

<PageTitle>フレーズ復習</PageTitle>

<MudStack Spacing="2">
    <SectionTitle Title="フレーズ復習" />

    <ActionCard>
        <MudButton Variant="Variant.Outlined" Size="@AppConstants.SIZE_BUTTON"
                   Color="Color.Primary" StartIcon="@Icons.Material.TwoTone.Shuffle"
                   Disabled="@(_count <= 1)" OnClick="Reshuffle">
            シャッフル
        </MudButton>

        <MudButton Variant="Variant.Filled" Size="@AppConstants.SIZE_BUTTON"
                   Color="Color.Primary" StartIcon="@Icons.Material.TwoTone.PlayArrow"
                   Disabled="@(_count == 0)" OnClick="GoWritingTest">
            英作文テストへ
        </MudButton>

        <MudButton Variant="Variant.Outlined" Size="@AppConstants.SIZE_BUTTON"
                   Color="Color.Default" StartIcon="@Icons.Material.TwoTone.ArrowBack"
                   OnClick="CancelAsync">
            フレーズ再選択
        </MudButton>
    </ActionCard>

    <BaseCard>
        <MudStack Spacing="2" AlignItems="AlignItems.Center" Class="py-4">

            <MudGrid Justify="Justify.Center">
                <MudItem xs="12" sm="10" md="8" lg="7" xl="6">
                    <MudSlider T="int"
                               Min="1"
                               Max="_count"
                               Step="1"
                               Value="_sliderValue"
                               ValueChanged="OnSliderChanged"
                               ValueLabel="true"
                               Disabled="@(_count <= 1)"
                               Color="Color.Primary"
                               Style="width:100%;" />
                </MudItem>
            </MudGrid>

            <MudText Typo="Typo.subtitle2">
                @(_count == 0 ? "（データなし）" : $"{_index + 1} / {_count}")
            </MudText>

            <!-- カード -->
            <MudGrid Justify="Justify.Center">
                <MudItem xs="12" sm="10" md="8" lg="7" xl="6">
                    <MudCard Elevation="12"
                             Class="w-100 p-6"
                             Style="height:clamp(240px, 36vh, 420px); cursor:pointer;"
                             @onclick="Flip">
                        <div tabindex="0"
                             @onkeydown="HandleKey"
                             @onkeydown:preventDefault="true"
                             style="outline:none;height:100%;display:flex;flex-direction:column;">

                            <!-- 本文 -->
                            <div style="flex:1 1 auto;display:flex;align-items:center;justify-content:center;overflow:auto;">
                                <MudCardContent Class="w-100">
                                    <MudText Typo="Typo.h5"
                                             Style="word-break:break-word;overflow-wrap:anywhere;">
                                        @(_count == 0 ? "" : _display)
                                    </MudText>
                                </MudCardContent>
                            </div>

                            <!-- クリック指示 -->
                            <div class="mt-2" style="flex:0 0 auto;min-height:1.5rem;width:100%;">
                                @if (_count > 0)
                                {
                                    <MudStack Justify="Justify.Center" AlignItems="AlignItems.Center">
                                        <MudText Typo="Typo.caption">
                                            @(_isBack ? "クリック / Space: 表へ" : "クリック / Space: 裏へ")
                                        </MudText>
                                    </MudStack>
                                }
                            </div>
                        </div>
                    </MudCard>
                </MudItem>
            </MudGrid>

            <!-- ナビ -->
            <MudGrid Justify="Justify.Center">
                <MudItem xs="12" sm="10" md="8" lg="7" xl="6">
                    <MudStack Row="true" Spacing="2" Justify="Justify.Center">
                        <MudButton Variant="Variant.Outlined" Size="@AppConstants.SIZE_BUTTON"
                                   StartIcon="@Icons.Material.TwoTone.FirstPage"
                                   Disabled="@(_count <= 0 || _index == 0)" OnClick="GoFirst">
                            先頭へ
                        </MudButton>

                        <MudButton Variant="Variant.Outlined" Size="@AppConstants.SIZE_BUTTON"
                                   StartIcon="@Icons.Material.TwoTone.ChevronLeft"
                                   Disabled="@(!_canPrev)" OnClick="Prev">
                            前へ
                        </MudButton>

                        <MudButton Variant="Variant.Outlined" Size="@AppConstants.SIZE_BUTTON"
                                   StartIcon="@Icons.Material.TwoTone.Sync"
                                   Disabled="@(_count == 0)" OnClick="Flip">
                            表/裏
                        </MudButton>

                        <MudButton Variant="Variant.Outlined" Size="@AppConstants.SIZE_BUTTON"
                                   EndIcon="@Icons.Material.TwoTone.ChevronRight"
                                   Disabled="@(!_canNext)" OnClick="Next">
                            次へ
                        </MudButton>

                        <MudButton Variant="Variant.Outlined" Size="@AppConstants.SIZE_BUTTON"
                                   EndIcon="@Icons.Material.TwoTone.LastPage"
                                   Disabled="@(_count <= 0 || _index == _count - 1)" OnClick="GoLast">
                            最後へ
                        </MudButton>
                    </MudStack>
                </MudItem>
            </MudGrid>

            <MudText Typo="Typo.caption" Class="mt-2">
                ← / → : 前・次　/　Space・Enter : 表裏切替
            </MudText>
        </MudStack>
    </BaseCard>
</MudStack>

@code {
    [Parameter, SupplyParameterFromQuery] public string? Return { get; set; }
    [Parameter, SupplyParameterFromQuery] public bool? Shuffle { get; set; }
    [Parameter, SupplyParameterFromQuery] public int? Start { get; set; }

    // PSS 一元化：UI内の作業配列は DTO をそのまま使う
    private List<ReviewCardDto> _items = new();
    private int _index;
    private bool _isBack;
    private int _count;
    private int _sliderValue;

    private bool _restoredFromPss;   // ★ 復元済みフラグ（初回描画後の既定シャッフル抑止用）

    private string _display => _isBack ? _items[_index].Back : _items[_index].Front;
    private bool _canPrev => _count > 0 && _index > 0;
    private bool _canNext => _count > 0 && _index < _count - 1;

    // ---- ライフサイクル ----
    protected override async Task OnParametersSetAsync()
    {
        // 常に PSS から復元（Setup で保存済み / 途中再開もこの状態を使う）
        var ok = await TryRestoreAsync();
        if (!ok)
        {
            Snackbar.Add("復習対象が設定されていません。フレーズ一覧から選択して開始してください。", Severity.Warning);
            NavigationManager.NavigateTo("/phrases");
            return;
        }

        // クエリ指定があれば上書きし、その状態を保存（再読み込みでも同じ位置から開始）
        if (Start.HasValue)
        {
            _index = Math.Clamp(Start.Value, 0, Math.Max(0, _count - 1));
            UpdateSlider();
            await SaveStateAsync();   // ★ Start 指定を永続化
        }

        // クエリの Shuffle 指定が true なら即シャッフル
        if ((Shuffle ?? false) && _count > 1)
        {
            ShuffleInPlace(_items, null);
            _index = 0;
            _isBack = false;
            UpdateSlider();
            await SaveStateAsync(shuffled: true);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        // 起動時のシャッフル既定（ユーザ嗜好）
        // ★ 既存セッションを PSS から復元できた場合は "継続" とみなし、ここではシャッフルしない
        if (!_restoredFromPss && !Shuffle.HasValue && _count > 1)
        {
            var r = await PSS.GetAsync<bool>(ReviewStorage.ShufflePrefV1);
            if (r.Success && r.Value)
            {
                ShuffleInPlace(_items, null);
                _index = 0;
                _isBack = false;
                UpdateSlider();
                StateHasChanged();
                await SaveStateAsync(shuffled: true);
            }
        }
    }

    // ---- セッション保存・復元 ----
    private async Task SaveStateAsync(bool shuffled = false)
    {
        if (_count == 0) return;

        var s = new ReviewState
        {
            Items = _items.Select(x => new ReviewCardDto
            {
                PhraseId = x.PhraseId,
                Front = x.Front,
                Back = x.Back
            }).ToList(),
            Index = _index,
            IsBack = _isBack,
            Shuffled = shuffled,
            SavedAtUtc = DateTime.UtcNow
        };
        await PSS.SetAsync(ReviewStorage.ReviewStateV1, s);
    }

    private async Task<bool> TryRestoreAsync()
    {
        try
        {
            var got = await PSS.GetAsync<ReviewState>(ReviewStorage.ReviewStateV1);
            var s = got.Success ? got.Value : null;
            if (s is null || s.Items.Count == 0) return false;

            _items = s.Items.ToList();
            _count = _items.Count;
            if (_count == 0) return false;

            _index = Math.Clamp(s.Index, 0, _count - 1);
            _isBack = s.IsBack;
            UpdateSlider();

            _restoredFromPss = true;   // ★ 復元済みマーク
            return true;
        }
        catch
        {
            return false;
        }
    }

    // ---- UI操作 ----
    private async void Prev() { if (_index > 0) _index--; _isBack = false; UpdateSlider(); await SaveStateAsync(); }
    private async void Next() { if (_index < _count - 1) _index++; _isBack = false; UpdateSlider(); await SaveStateAsync(); }
    private async void GoFirst() { _index = 0; _isBack = false; UpdateSlider(); await SaveStateAsync(); }
    private async void GoLast() { if (_count == 0) return; _index = _count - 1; _isBack = false; UpdateSlider(); await SaveStateAsync(); }
    private async void Flip() { _isBack = !_isBack; await SaveStateAsync(); }

    private async void Reshuffle()
    {
        if (_count <= 1) return;
        ShuffleInPlace(_items, null);
        _index = 0;
        _isBack = false;
        UpdateSlider();
        await PSS.SetAsync(ReviewStorage.ShufflePrefV1, true);
        await SaveStateAsync(shuffled: true);
    }

    private async void OnSliderChanged(int value)
    {
        if (_count == 0) return;
        var newIndex = Math.Clamp(value - 1, 0, _count - 1);
        if (newIndex != _index)
        {
            _index = newIndex;
            _isBack = false;
        }
        _sliderValue = value;
        await SaveStateAsync();
    }

    private void UpdateSlider() => _sliderValue = _index + 1;

    private static void ShuffleInPlace<T>(IList<T> list, int? seed)
    {
        var rnd = seed.HasValue ? new Random(seed.Value) : new Random();
        for (int i = list.Count - 1; i > 0; i--)
        {
            int j = rnd.Next(i + 1);
            (list[i], list[j]) = (list[j], list[i]);
        }
    }

    private void HandleKey(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft": Prev(); break;
            case "ArrowRight": Next(); break;
            case " ":
            case "Enter": Flip(); break;
        }
    }

    private async Task CancelAsync()
    {
        if (!string.IsNullOrEmpty(Return))
        {
            NavigationManager.NavigateTo(Return);
            return;
        }
        try
        {
            await JS.HistoryBackAsync();
        }
        catch
        {
            NavigationManager.NavigateTo("/phrases");
        }
    }

    private void GoWritingTest()
    {
        // PSS はクリアしない：英作文テストページのリロード耐性のため
        NavigationManager.NavigateTo("/phrases/writing");
    }
}
