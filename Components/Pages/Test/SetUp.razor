@page "/tests/setup"
@attribute [Authorize]

@inject PhraseService PhraseService
@inject GenreService GenreService
@inject PhraseBookService PhraseBookService
@inject ReviewSession ReviewSession
@inject NavigationManager Nav
@inject ISnackbar Snackbar
@inject UiOperationRunner UiRunner
@inject JsInteropManager JS

<PageTitle>テスト設定</PageTitle>

<MudStack Spacing="2">
    <SectionTitle Title="テスト設定" />

    <ActionCard>
        <MudButton Variant="Variant.Outlined" Color="Color.Primary"
                   StartIcon="@Icons.Material.TwoTone.Visibility"
                   OnClick="PreviewAsync">プレビュー</MudButton>

        <MudSpacer />

        <MudButton Variant="Variant.Outlined" Color="Color.Default"
                   StartIcon="@Icons.Material.TwoTone.RestartAlt"
                   OnClick="ResetFilters">条件クリア</MudButton>
    </ActionCard>

    <BaseCard Class="pa-4" Style="min-height: 400px;">
        <MudStack Spacing="2" Class="mt-2">

            <MudText Typo="Typo.subtitle2">出題範囲</MudText>

            <!-- フレーズ帳（複数選択） -->
            <MudText Typo="Typo.caption">フレーズ帳</MudText>
            <MudSelect T="Guid"
                       Label="フレーズ帳を選択"
                       MultiSelection="true"
                       SelectedValues="_f.PhraseBookIds"
                       SelectedValuesChanged="@EventCallback.Factory.Create(this, (IEnumerable<Guid> ids) => OnPhraseBookIdsChangedAsync(ids))"
                       ToStringFunc="GetPhraseBookName"
                       Dense="true" Variant="Variant.Outlined" Margin="Margin.Dense">
                @foreach (var b in _books)
                {
                    <MudSelectItem T="Guid" Value="@b.Id">@b.Name</MudSelectItem>
                }
            </MudSelect>

            @if (_hasAnyAvailableGenre)
            {
                <!-- ジャンル／サブジャンル -->
                <MudText Typo="Typo.caption" Class="mt-2">ジャンル／サブジャンル（複数選択）</MudText>

                <MudTextField T="string"
                              @bind-Value="_genreFilter"
                              Variant="Variant.Outlined"
                              Margin="Margin.Dense"
                              Placeholder="ジャンル・サブジャンル名で絞り込み" />

                <MudPaper Outlined="true" Elevation="0" Square="true"
                          Class="pa-1"
                          Style="max-height:300px; overflow:auto;">
                    <MudList T="Guid"
                             SelectionMode="SelectionMode.MultiSelection"
                             SelectedValues="_f.SubGenreIds"
                             SelectedValuesChanged="@EventCallback.Factory.Create(this, (object? e) => OnSubGenreIdsChanged(ToSet(e)))"
                             Dense="true"
                             CheckBoxColor="Color.Default">
                        <MudListSubheader>ジャンル / サブジャンル</MudListSubheader>

                        @foreach (var g in _genres)
                        {
                            var availableChildren = (g.SubGenres?.OrderBy(x => x.OrderNo) ?? Enumerable.Empty<SubGenreModel>())
                            .Where(sg => _availableSubGenreIds.Contains(sg.Id));

                            var showAllChildren = string.IsNullOrWhiteSpace(_genreFilter) || ContainsCi(g.Name, _genreFilter);
                            var filteredChildren = showAllChildren
                            ? availableChildren
                            : availableChildren.Where(sg => ContainsCi(sg.Name, _genreFilter));

                            var childList = filteredChildren.ToList();
                            if (childList.Count == 0) { continue; }

                            <MudListItem>
                                <ChildContent>
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                        <MudCheckBox T="bool?"
                                                     TriState="true"
                                                     Value="@GetGenreCheckStateVisible(g)"
                                                     ValueChanged="@((bool? v) => OnGenreCheckChangedVisible(g, v))" />
                                        <MudText>@g.Name</MudText>
                                        <MudText Typo="Typo.caption" Color="Color.Secondary">
                                            (@GetSelectedCountWithinVisible(g)/@GetVisibleChildCount(g))
                                        </MudText>
                                    </MudStack>
                                </ChildContent>
                                <NestedList>
                                    @foreach (var sg in childList)
                                    {
                                        <MudListItem T="Guid" Value="@sg.Id">
                                            <ChildContent>@sg.Name</ChildContent>
                                        </MudListItem>
                                    }
                                </NestedList>
                            </MudListItem>
                        }
                    </MudList>
                </MudPaper>
            }

            <!-- 期間 -->
            <MudText Typo="Typo.subtitle2" Class="mt-2">期間</MudText>
            <MudSelect T="DateRangePreset" Label="期間"
                       Value="_f.DatePreset"
                       ValueChanged="OnDatePresetChanged"
                       Margin="Margin.Dense" Variant="Variant.Outlined" Dense="true">
                <MudSelectItem Value="DateRangePreset.None">指定なし</MudSelectItem>
                <MudSelectItem Value="DateRangePreset.Today">今日</MudSelectItem>
                <MudSelectItem Value="DateRangePreset.Yesterday">昨日</MudSelectItem>
                <MudSelectItem Value="DateRangePreset.Last7Days">直近7日以内</MudSelectItem>
                <MudSelectItem Value="DateRangePreset.Last30Days">直近30日以内</MudSelectItem>
                <MudSelectItem Value="DateRangePreset.Custom">カスタム</MudSelectItem>
            </MudSelect>

            @if (_f.DatePreset == DateRangePreset.Custom)
            {
                <MudDatePicker Label="開始日"
                               Date="_f.DateFrom"
                               DateChanged="OnDateFromChanged"
                               Margin="Margin.Dense" Variant="Variant.Outlined" />
                <MudDatePicker Label="終了日"
                               Date="_f.DateTo"
                               DateChanged="OnDateToChanged"
                               Margin="Margin.Dense" Variant="Variant.Outlined" />
                @if (!_isDateRangeValid)
                {
                    <MudAlert Severity="Severity.Warning" Dense="true" Variant="Variant.Outlined" Elevation="0">
                        期間の指定が不正です。開始日は終了日以前にしてください。
                    </MudAlert>
                }
            }

            <!-- オプション -->
            <MudText Typo="Typo.subtitle2" Class="mt-2">オプション</MudText>

            <MudSwitch T="bool" Label="テスト未実施のみ"
                       Value="_f.UntestedOnly"
                       ValueChanged="OnUntestedOnlyChanged"
                       Color="Color.Primary" />

            <MudSelect T="int" Label="出題数"
                       Value="_f.Limit"
                       ValueChanged="OnLimitChanged"
                       Margin="Margin.Dense" Variant="Variant.Outlined" Dense="true">
                @foreach (var n in _limitOptions)
                {
                    <MudSelectItem T="int" Value="@n">@n</MudSelectItem>
                }
            </MudSelect>

            <MudSwitch T="bool" Label="シャッフル"
                       Value="_f.Shuffle"
                       ValueChanged="OnShuffleChanged"
                       Color="Color.Primary" />

            @* ▼ プレビュー *@
            @if (_hasPreview)
            {
                <div id="@PreviewAnchorId"></div>
                <SelectableTable TItem="PhraseListItemModel"
                                 @ref="_previewTable"
                                 Items="@_preview"
                                 IdSelector="@(x => x.Id)"
                                 Search="true"
                                 SearchPlaceholder="検索（英語・意味）"
                                 SearchBy="SearchByPreview"
                                 RowsPerPage="10"
                                 Height="420px">

                    <ExtraToolbar Context="ctx">
                        <MudText Typo="Typo.caption">
                            選択：@ctx.SelectedCountInView 件（検索結果内）
                        </MudText>

                        <MudButton Variant="Variant.Outlined" Color="Color.Secondary"
                                   StartIcon="@Icons.Material.TwoTone.Style"
                                   Disabled="@(ctx.GetSelectedIdsAll().Count == 0)"
                                   OnClick="@(() => StartFromSelection(ctx.GetSelectedIdsAll(), true))">
                            復習してから開始
                        </MudButton>

                        <MudButton Variant="Variant.Filled" Color="Color.Primary"
                                   StartIcon="@Icons.Material.TwoTone.PlayArrow"
                                   Disabled="@(ctx.GetSelectedIdsAll().Count == 0)"
                                   OnClick="@(() => StartFromSelection(ctx.GetSelectedIdsAll(), false))">
                            テスト開始
                        </MudButton>
                    </ExtraToolbar>

                    <HeaderContent>
                        <MudTh>フレーズ</MudTh>
                        <MudTh>意味</MudTh>
                    </HeaderContent>

                    <RowTemplate Context="it">
                        <MudTd>@it.Phrase</MudTd>
                        <MudTd>@it.Meaning</MudTd>
                    </RowTemplate>

                    <NoRecordsContent>
                        <MudText Typo="Typo.caption" Class="p-2">該当がありません。</MudText>
                    </NoRecordsContent>
                </SelectableTable>
            }

        </MudStack>
    </BaseCard>
</MudStack>

@code {
    private const string ReturnTarget = "/tests/setup";
    private static string BuildReturnQuery() => $"?Return={Uri.EscapeDataString(ReturnTarget)}";

    private readonly int[] _limitOptions = new[] { 5, 10, 20, 30, 50, 100 };

    private TestFilterModel _f = new();
    private SelectableTable<PhraseListItemModel>? _previewTable;

    private List<GenreModel> _genres = new();
    private List<PhraseBookListItemModel> _books = new();
    private List<PhraseListItemModel> _preview = new();

    private HashSet<Guid> _availableSubGenreIds = new();
    private bool _hasAnyAvailableGenre;

    private bool _hasPreview;
    private bool _isDateRangeValid = true;
    private const string PreviewAnchorId = "setup-preview-anchor";
    private bool _pendingScrollToPreview;

    private string _genreFilter = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        // 初期値：直近30日 / 出題数 10
        _f.DatePreset = DateRangePreset.Last30Days;
        _f.Limit = 10;
        _f.UntestedOnly = false;

        _genres = await UiRunner.ReadAsync(() => GenreService.GetGenreViewModelListAsync()) ?? new();
        _books = await UiRunner.ReadAsync(() => PhraseBookService.GetPhraseBooksAsync()) ?? new();

        await RefreshAvailableSubGenresAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // ★ 追加：初回レンダー後に AttachJs + Restore（保存の有効化と復元）
        if (firstRender)
        {
            ReviewSession.AttachJs(JS);
            await ReviewSession.RestoreAsync();
        }

        if (_pendingScrollToPreview)
        {
            _pendingScrollToPreview = false;
            await JS.ScrollToIdAsync(PreviewAnchorId, smooth: true);
        }
    }

    private void InvalidatePreview()
    {
        _hasPreview = false;
        _preview.Clear();
        StateHasChanged();
    }

    private async Task OnPhraseBookIdsChangedAsync(IEnumerable<Guid> ids)
    {
        _f.PhraseBookIds = ids?.ToHashSet() ?? new HashSet<Guid>();
        await RefreshAvailableSubGenresAsync();
        InvalidatePreview();
    }

    private void OnSubGenreIdsChanged(HashSet<Guid> ids)
    {
        _f.SubGenreIds = ids ?? new HashSet<Guid>();
        InvalidatePreview();
    }

    private void OnDatePresetChanged(DateRangePreset preset)
    {
        if (_f.DatePreset == preset) return;
        _f.DatePreset = preset;
        if (preset != DateRangePreset.Custom)
        {
            _f.DateFrom = null;
            _f.DateTo = null;
            _isDateRangeValid = true;
        }
        InvalidatePreview();
    }
    private void OnDateFromChanged(DateTime? from)
    {
        _f.DateFrom = from;
        _isDateRangeValid = CheckDateRange();
        InvalidatePreview();
    }
    private void OnDateToChanged(DateTime? to)
    {
        _f.DateTo = to;
        _isDateRangeValid = CheckDateRange();
        InvalidatePreview();
    }
    private void OnUntestedOnlyChanged(bool v)
    {
        if (_f.UntestedOnly == v) return;
        _f.UntestedOnly = v;
        InvalidatePreview();
    }
    private void OnShuffleChanged(bool v)
    {
        if (_f.Shuffle == v) return;
        _f.Shuffle = v;
        InvalidatePreview();
    }
    private void OnLimitChanged(int v)
    {
        if (_f.Limit == v) return;
        _f.Limit = v;
        // プレビュー再計算は不要（開始時に Take）
    }

    // TriState（可視の子のみで判定）
    private bool? GetGenreCheckStateVisible(GenreModel g)
    {
        var ids = g.SubGenres?
            .Where(sg => _availableSubGenreIds.Contains(sg.Id))
            .Select(x => x.Id)
            .ToArray() ?? Array.Empty<Guid>();
        if (ids.Length == 0) return false;

        int sel = ids.Count(id => _f.SubGenreIds.Contains(id));
        if (sel == 0) return false;
        if (sel == ids.Length) return true;
        return null;
    }
    private void OnGenreCheckChangedVisible(GenreModel g, bool? v)
    {
        var ids = g.SubGenres?
            .Where(sg => _availableSubGenreIds.Contains(sg.Id))
            .Select(x => x.Id)
            .ToArray() ?? Array.Empty<Guid>();

        var next = _f.SubGenreIds.ToHashSet();

        if (v == true) next.UnionWith(ids);
        else if (v == false) next.RemoveWhere(id => ids.Contains(id));
        else next.UnionWith(ids);

        _f.SubGenreIds = next;
        InvalidatePreview();
    }

    private int GetVisibleChildCount(GenreModel g)
        => g.SubGenres?.Count(sg => _availableSubGenreIds.Contains(sg.Id)) ?? 0;

    private int GetSelectedCountWithinVisible(GenreModel g)
        => g.SubGenres?.Count(sg => _availableSubGenreIds.Contains(sg.Id) && _f.SubGenreIds.Contains(sg.Id)) ?? 0;

    private async Task RefreshAvailableSubGenresAsync()
    {
        var ids = await UiRunner.ReadAsync(() => PhraseService.GetAvailableSubGenreIdsAsync(_f));
        _availableSubGenreIds = ids ?? new HashSet<Guid>();

        _f.SubGenreIds.IntersectWith(_availableSubGenreIds);

        _hasAnyAvailableGenre = _genres.Any(g => g.SubGenres?.Any(sg => _availableSubGenreIds.Contains(sg.Id)) == true);

        StateHasChanged();
    }

    private async Task PreviewAsync()
    {
        if (_f.DatePreset == DateRangePreset.Custom)
        {
            _isDateRangeValid = CheckDateRange();
            if (!_isDateRangeValid)
            {
                Snackbar.Add("期間の指定が不正です。開始日と終了日を確認してください。", Severity.Warning);
                return;
            }
        }

        _preview = await UiRunner.ReadWithOverlayAsync(
            () => PhraseService.BuildCandidatesAsync(_f),
            "対象を抽出中…") ?? new();

        _hasPreview = _preview.Count > 0;

        if (_hasPreview)
        {
            _pendingScrollToPreview = true;
            StateHasChanged();
        }
        else
        {
            Snackbar.Add("該当データがありません。条件を見直してください。", Severity.Warning);
        }
    }

    private void StartFromSelection(HashSet<Guid> selectedIds, bool review)
    {
        if (!_hasPreview)
        {
            Snackbar.Add("まずはプレビューを実行してください。", Severity.Info);
            return;
        }
        if (selectedIds is null || selectedIds.Count == 0)
        {
            Snackbar.Add("1件以上を選択してください。", Severity.Warning);
            return;
        }

        var items = _preview.Where(x => selectedIds.Contains(x.Id)).ToList();
        if (_f.Shuffle)
        {
            var rnd = Random.Shared;
            items = items.OrderBy(_ => rnd.Next()).ToList();
        }
        items = items.Take(Math.Clamp(_f.Limit, 1, int.MaxValue)).ToList();

        // ReviewSession は AttachJs 済みなので Set => 自動保存される
        ReviewSession.Set(items, x => x.Id, x => x.Phrase, x => x.Meaning);
        var ret = BuildReturnQuery();
        Nav.NavigateTo(review ? $"/phrases/review{ret}" : $"/phrases/writing{ret}");
    }

    private static bool ContainsCi(string? text, string? term)
        => !string.IsNullOrWhiteSpace(text) && !string.IsNullOrWhiteSpace(term)
           && text.Contains(term, StringComparison.OrdinalIgnoreCase);

    private string GetPhraseBookName(Guid id)
        => _books.FirstOrDefault(x => x.Id == id)?.Name ?? id.ToString();

    private static HashSet<Guid> ToSet(object? e)
        => e switch
        {
            HashSet<Guid> hs => hs,
            IEnumerable<Guid> en => en.ToHashSet(),
            _ => new HashSet<Guid>()
        };

    private bool CheckDateRange()
        => !(_f.DateFrom.HasValue && _f.DateTo.HasValue && _f.DateFrom.Value.Date > _f.DateTo.Value.Date);

    private void ResetFilters()
    {
        _f = new TestFilterModel
        {
            DatePreset = DateRangePreset.Last30Days,
            Limit = 10,
            UntestedOnly = false,
        };
        _genreFilter = string.Empty;
        _preview.Clear();
        _hasPreview = false;

        _ = RefreshAvailableSubGenresAsync();
    }

    // SelectableTable 用：検索対象列
    private IEnumerable<string> SearchByPreview(PhraseListItemModel x)
        => new[] { x.Phrase ?? string.Empty, x.Meaning ?? string.Empty };
}
